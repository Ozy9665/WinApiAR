WinApi AR

기본(1)

HINSTANCE hInstance : 실행 된 프로세스의 시작 주소

리소스 뷰 - 스트링테이블 - IDS_APP_TITLE, IDC_WINAPIAR 등을
LoadStringW 에서 전역 문자열 초기화 IDS_APP_TITLE -> szTitle

프로세스 = 윈도우 가 아님
윈도우는 인터페이스 역할, 프로세스는 윈도우를 가질 수도, 아닐 수도 있음
하나의 프로세스에서 여러개의 창을 띄울 수도 있음 ex) 창 띄우고 도움말 창까지

MyRegisterClass : 창 클래스 등록, 값 세팅
- 함수포인터 lpfnWndProc  = WndProc; <- 콜백함수 WndProc

Accel table - 단축키 등록
 Alt + ? -> 도움말(정보)
 Alt + / -> 

함수: WndProc(HWND, UINT, WPARAM, LPARAM)

용도: 주 창의 메시지를 처리합니다.

WM_COMMAND  - 애플리케이션 메뉴를 처리합니다.
WM_PAINT    - 주 창을 그립니다.
WM_DESTROY  - 종료 메시지를 게시하고 반환합니다.



기본 메세지 루프
- 메세지 큐 
   &msg로 메세지를 받아 처리 (msg.message, msg.time, msg.lParap, msg.pt 등등)을 큐에서 꺼내 채워줌
   TranslateMessage, DispatchMessge 로 처리
   msg.hwnd - 메세지가 발생한 윈도우 
   들어온 메세지를 분석(translate)하고 (단축키인지 확인도 하고) -> 관련 처리기 쪽으로 보냄(dispatch)
   -> WndProc가 호출되고 메세지가 어떤 지에 따라 분기처리(switch), 윈도우메세지가 너무 많기 떄문에 모든 메세지를 처리할 순없음
   -> DefWindowProc(디폴트)를 통해서 처리

   GetMessage - 메세지큐에서 메세지를 확인할 때 가지 대기
   GetMessage에서 false를 반환하는 경우 - WM_QUIT일 때 -> while문 종료 -> 프로그램 종료

   메세지 반응 형태이기 때문에 게임개발에 부적합
   - 이유 : 
   

   -> 구조 변경할 예정


기본(2)

복습내용

WinMain : 윈도우 생성 - 반복문 돌며 메세지확인, 처리
	ex) WM_PAINT 메세지가 들어오면 그리기 작업
	  WM_PAINT 가 발생해야 하는 상황 -> 윈도우의 무효화 영역이 발생한 경우 
	  (invalidate Rect) :
	  인터넷 설명 : 윈도우가 다른 창에 가려졌다가 다시 포커스 <- 가려졌던 부분이 무효화 영역
	  정말 그러한가? -> but 디버그 해보니 호출 안 됨 / 그런데 창을 최소화 했다가 다시 키면 발생
	  * 가려졌던 부분이 무효화영역이라는 것은 오래된 설명
	   화면에 가려진 부분은 비트맵형태로 데이터를 가지고 있기 때문에 현재는 맞지 않는 설명


윈도우를 구성하는 최소한의 정보들이 있음 - CreateWindow를 통해 만듬
동작
OS가 관리하는 커널오브젝트들은 ID를제공. -> 그 값(핸들)으로 ShowWindow등 제공된 함수,아이디 이용

HDC hde // Device Context (커널)(그리기 관련)
* DC(Device Context)를 만들때는 윈도우(목적지)를 알려줌(hWnd)
Device Context란?(장치 컨텍스트)
화면에 그리기 동작을 할 수 있게 그리기 작업을 하는데 필요한 데이터 들의 집합체 (펜,브러시,)
=> 뭔가를 그릴 땐 항상 DC이용 : 그 안에 있는 펜 정보, 브러시 정보등을 이용하여 그리겠다.
(디폴트 : 검은색 펜, 하얀색 브러시)




HDC, HWND 와 같은 애들의 자료형 : DECLARE_HANDLE이라는 전처리기 : 구조체,멤버로 인트가 하나 들어있음 
=> 전처리기에 의해서 HDC{int a;} typedef HDC 와 같은 형식
=> int하난데 굳이 구조체를? => 
=> HDC.HWND,HBRUSH등 다양하게 하는 이유? => 다 같은 커널오브젝트지만 종류가 완전히 다름 (윈도우, 펜, 브러쉬, DC) => 통일하지 않고 구분
* H 붙으면 id라는 뜻



*픽셀 하나당 R,G,B 1바이트 씩 총 3바이트 / 1920x1080 = 6,220,800 바이트 = 약 6MB
 0~255중 0,0,0 : 검은색



----4강 윈도우이벤트(2)---
직접 펜을 만들어서 DC에 지급하는 방법
HPEN hRedPen = CreatePen(스타일,폭,색상);	// 스타일은 MS 레퍼런스 참고
HPEN hDefaultPen = (HPEN)SelectObject(hdc, hRedPen);
* 왜 굳이 HPEN 캐스팅이 필요한 구조인지? => SelectObject함수는 범용적인 함수이기 때문(펜, 브러쉬등 용도에 따라)


Create 말고 GetStockObject도 가능(자주쓰는 애들을 가져다쓰는 함수)
	브러쉬 : 검정,회색, 어두은 회색, 투명한브러쉬, 하양
	펜 : 검,하 등등
*Create한게 아니니 삭제도 x

만든다면 CreateSolidBrush(색상) 사용

WM_KEYDOWN : 키 정보 - wParam으로 들어옴	/ 마우스는 lParam
							lParam의 자료형 LONG_PTR : long자료형 (4바이트 정수) / 2바이트 씩 좌표받을 수 있음(LOWORD HIWORD)


이동 시키려면 WM_PAINT에서 고정된 위치(상수)로 그리면 안됨

POINT : x,y로 구성된 구조체

WM_KEYDOWN 에서 switch문을 이용해 VK_UP, DOWN 등 활용
좌표를 바꿔줬으면 다시 그려주는 작업 필요함

윈도우는 무효화영역 발생 시 WM_PAINT 를 발생시킴
하는 점을 이용한 
InvalidateRect(윈도우, 영역(nullptr은 전체), bErase)으로 무효화 영역발생 => 다시 그려주기 

bErase 를 false로 할 시 이전 그림이 남아있음
true로 이전 그림 지우기=>InvalidateRect(hWnd, nullptr, true);

여기까지만 했을 때는 꾹 눌렀을 때 한 템포 느림

다음시간 : 조작 + 물체여러개



PeekMessage(1)	여러 오브젝트 그리기

여러물체를 그려낸다면?
게임이란 렌더링 - 매 순간 변경점을 적용하기 위하여 화면을 그리고 그리는 과정의 연속 - frame : pc는 60은 나와줘야 안정적	/ 콘솔은 30목표

WM_LBUTTONDOWN 에서 마우스 좌상단
WM_MOUSEMOVE에서 마우스 우하단 기억

물체가 늘어날수록 깜빡임 심해짐
- 현재 렌더링 과정 : 다지우고 다시 그리기
	가 마우스가 조금이라도 움직일 떄 마다 무효화영역->다시그려주기 계속 하고 있음 / 메세지가 있어야(변화가 있어야) 다시 그림
해결법! -> 우리가 그릴 도화지를 2개를 관리함
해결법? : 타이머 이용 - 일정시간마다 계속 그려주도록 강제 - SetTimer , WM_TIMER 이용 -> 굉장히 안 좋은 성능(매 프레임을 메세지발생-처리)
		-> 윈도우메세지처리기반 방식을 최대한 처리하지 않는 방식으로 해결해야 함 : 방법이 있긴 있다! -> 메세지 반응 형태 구조 살짝 변경
=> 기본 메세지 루프인
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    } 를 조금 변경할 예정


GetMessage - 메세지큐에서 메세지를 꺼내옴. *함수가 메세지큐에 메세지가 들어올 때까지 대기*
-> 메세지가 있던 없던 반환이 되는 함수를 써야하지 않을까? 
-> PeekMessage(); 사용하여 메세지를 슬쩍본다.
PeekMessage는 인자를 하나 더 : 메세지를 보고 삭제를 할지 안 할지. 삭제 시 PM_REMOVE로 메세지큐에 메세지가 쌓이지 않도록

GetMessage의 리턴값이 while문의 조건으로 된 이유 -> GetMessage는 항상 특정 반환값이 있고 false(WM_QUIT)일 경우 종료
PeekMessage는 메세지가 없어도 반환 - while문의 조건이 될 수 있을까?? x
-> 그럼 PeekMessage의 반환 값은 언제true이고 언제 false인가? -> 메세지가 있을 떄 true, 없으면 false
=> 메세지가 없을 때에도 계속 프로그램이 돌아가는 구조


일반적으로 메세지 처리쪽의 시간은 굉장히 작음
메세지를 처리하지 않는 쪽 비율이 많음 - 비는 시간이 많음
=> 메세지 기반 방식을 바꿔주는 이유

비동기함수


Game코드수행
디자인패턴(설계유형)
**싱글톤 패턴**




