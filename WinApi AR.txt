WinApi AR

기본(1)

HINSTANCE hInstance : 실행 된 프로세스의 시작 주소

리소스 뷰 - 스트링테이블 - IDS_APP_TITLE, IDC_WINAPIAR 등을
LoadStringW 에서 전역 문자열 초기화 IDS_APP_TITLE -> szTitle

프로세스 = 윈도우 가 아님
윈도우는 인터페이스 역할, 프로세스는 윈도우를 가질 수도, 아닐 수도 있음
하나의 프로세스에서 여러개의 창을 띄울 수도 있음 ex) 창 띄우고 도움말 창까지

MyRegisterClass : 창 클래스 등록, 값 세팅
- 함수포인터 lpfnWndProc  = WndProc; <- 콜백함수 WndProc

Accel table - 단축키 등록
 Alt + ? -> 도움말(정보)
 Alt + / -> 

함수: WndProc(HWND, UINT, WPARAM, LPARAM)

용도: 주 창의 메시지를 처리합니다.

WM_COMMAND  - 애플리케이션 메뉴를 처리합니다.
WM_PAINT    - 주 창을 그립니다.
WM_DESTROY  - 종료 메시지를 게시하고 반환합니다.



기본 메세지 루프
- 메세지 큐 
   &msg로 메세지를 받아 처리 (msg.message, msg.time, msg.lParap, msg.pt 등등)을 큐에서 꺼내 채워줌
   TranslateMessage, DispatchMessge 로 처리
   msg.hwnd - 메세지가 발생한 윈도우 
   들어온 메세지를 분석(translate)하고 (단축키인지 확인도 하고) -> 관련 처리기 쪽으로 보냄(dispatch)
   -> WndProc가 호출되고 메세지가 어떤 지에 따라 분기처리(switch), 윈도우메세지가 너무 많기 떄문에 모든 메세지를 처리할 순없음
   -> DefWindowProc(디폴트)를 통해서 처리

   GetMessage - 메세지큐에서 메세지를 확인할 때 가지 대기
   GetMessage에서 false를 반환하는 경우 - WM_QUIT일 때 -> while문 종료 -> 프로그램 종료

   메세지 반응 형태이기 때문에 게임개발에 부적합
   - 이유 : 
   

   -> 구조 변경할 예정


기본(2)

복습내용

WinMain : 윈도우 생성 - 반복문 돌며 메세지확인, 처리
	ex) WM_PAINT 메세지가 들어오면 그리기 작업
	  WM_PAINT 가 발생해야 하는 상황 -> 윈도우의 무효화 영역이 발생한 경우 
	  (invalidate Rect) :
	  인터넷 설명 : 윈도우가 다른 창에 가려졌다가 다시 포커스 <- 가려졌던 부분이 무효화 영역
	  정말 그러한가? -> but 디버그 해보니 호출 안 됨 / 그런데 창을 최소화 했다가 다시 키면 발생
	  * 가려졌던 부분이 무효화영역이라는 것은 오래된 설명
	   화면에 가려진 부분은 비트맵형태로 데이터를 가지고 있기 때문에 현재는 맞지 않는 설명


윈도우를 구성하는 최소한의 정보들이 있음 - CreateWindow를 통해 만듬
동작
OS가 관리하는 커널오브젝트들은 ID를제공. -> 그 값(핸들)으로 ShowWindow등 제공된 함수,아이디 이용

HDC hde // Device Context (커널)(그리기 관련)
* DC(Device Context)를 만들때는 윈도우(목적지)를 알려줌(hWnd)
Device Context란?(장치 컨텍스트)
화면에 그리기 동작을 할 수 있게 그리기 작업을 하는데 필요한 데이터 들의 집합체 (펜,브러시,)
=> 뭔가를 그릴 땐 항상 DC이용 : 그 안에 있는 펜 정보, 브러시 정보등을 이용하여 그리겠다.
(디폴트 : 검은색 펜, 하얀색 브러시)




HDC, HWND 와 같은 애들의 자료형 : DECLARE_HANDLE이라는 전처리기 : 구조체,멤버로 인트가 하나 들어있음 
=> 전처리기에 의해서 HDC{int a;} typedef HDC 와 같은 형식
=> int하난데 굳이 구조체를? => 
=> HDC.HWND,HBRUSH등 다양하게 하는 이유? => 다 같은 커널오브젝트지만 종류가 완전히 다름 (윈도우, 펜, 브러쉬, DC) => 통일하지 않고 구분
* H 붙으면 id라는 뜻



*픽셀 하나당 R,G,B 1바이트 씩 총 3바이트 / 1920x1080 = 6,220,800 바이트 = 약 6MB
 0~255중 0,0,0 : 검은색



----4강 윈도우이벤트(2)---
직접 펜을 만들어서 DC에 지급하는 방법
HPEN hRedPen = CreatePen(스타일,폭,색상);	// 스타일은 MS 레퍼런스 참고
HPEN hDefaultPen = (HPEN)SelectObject(hdc, hRedPen);
* 왜 굳이 HPEN 캐스팅이 필요한 구조인지? => SelectObject함수는 범용적인 함수이기 때문(펜, 브러쉬등 용도에 따라)


Create 말고 GetStockObject도 가능(자주쓰는 애들을 가져다쓰는 함수)
	브러쉬 : 검정,회색, 어두은 회색, 투명한브러쉬, 하양
	펜 : 검,하 등등
*Create한게 아니니 삭제도 x

만든다면 CreateSolidBrush(색상) 사용

WM_KEYDOWN : 키 정보 - wParam으로 들어옴	/ 마우스는 lParam
							lParam의 자료형 LONG_PTR : long자료형 (4바이트 정수) / 2바이트 씩 좌표받을 수 있음(LOWORD HIWORD)


이동 시키려면 WM_PAINT에서 고정된 위치(상수)로 그리면 안됨

POINT : x,y로 구성된 구조체

WM_KEYDOWN 에서 switch문을 이용해 VK_UP, DOWN 등 활용
좌표를 바꿔줬으면 다시 그려주는 작업 필요함

윈도우는 무효화영역 발생 시 WM_PAINT 를 발생시킴
하는 점을 이용한 
InvalidateRect(윈도우, 영역(nullptr은 전체), bErase)으로 무효화 영역발생 => 다시 그려주기 

bErase 를 false로 할 시 이전 그림이 남아있음
true로 이전 그림 지우기=>InvalidateRect(hWnd, nullptr, true);

여기까지만 했을 때는 꾹 눌렀을 때 한 템포 느림

다음시간 : 조작 + 물체여러개



PeekMessage(1)	여러 오브젝트 그리기

여러물체를 그려낸다면?
게임이란 렌더링 - 매 순간 변경점을 적용하기 위하여 화면을 그리고 그리는 과정의 연속 - frame : pc는 60은 나와줘야 안정적	/ 콘솔은 30목표

WM_LBUTTONDOWN 에서 마우스 좌상단
WM_MOUSEMOVE에서 마우스 우하단 기억

물체가 늘어날수록 깜빡임 심해짐
- 현재 렌더링 과정 : 다지우고 다시 그리기
	가 마우스가 조금이라도 움직일 떄 마다 무효화영역->다시그려주기 계속 하고 있음 / 메세지가 있어야(변화가 있어야) 다시 그림
해결법! -> 우리가 그릴 도화지를 2개를 관리함
해결법? : 타이머 이용 - 일정시간마다 계속 그려주도록 강제 - SetTimer , WM_TIMER 이용 -> 굉장히 안 좋은 성능(매 프레임을 메세지발생-처리)
		-> 윈도우메세지처리기반 방식을 최대한 처리하지 않는 방식으로 해결해야 함 : 방법이 있긴 있다! -> 메세지 반응 형태 구조 살짝 변경
=> 기본 메세지 루프인
    while (GetMessage(&msg, nullptr, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    } 를 조금 변경할 예정


GetMessage - 메세지큐에서 메세지를 꺼내옴. *함수가 메세지큐에 메세지가 들어올 때까지 대기*
-> 메세지가 있던 없던 반환이 되는 함수를 써야하지 않을까? 
-> PeekMessage(); 사용하여 메세지를 슬쩍본다.
PeekMessage는 인자를 하나 더 : 메세지를 보고 삭제를 할지 안 할지. 삭제 시 PM_REMOVE로 메세지큐에 메세지가 쌓이지 않도록

GetMessage의 리턴값이 while문의 조건으로 된 이유 -> GetMessage는 항상 특정 반환값이 있고 false(WM_QUIT)일 경우 종료
PeekMessage는 메세지가 없어도 반환 - while문의 조건이 될 수 있을까?? x
-> 그럼 PeekMessage의 반환 값은 언제true이고 언제 false인가? -> 메세지가 있을 떄 true, 없으면 false
=> 메세지가 없을 때에도 계속 프로그램이 돌아가는 구조


일반적으로 메세지 처리쪽의 시간은 굉장히 작음
메세지를 처리하지 않는 쪽 비율이 많음 - 비는 시간이 많음
=> 메세지 기반 방식을 바꿔주는 이유

비동기함수


Game코드수행
디자인패턴(설계유형)
**싱글톤 패턴**


===== Core클래스 / Singletone =====	(1)
**Core라는 클래스가 프로그램 자체를 나타낸다.** - (정확히는 Core로 만들어진 객체이다)
								(-> 그럼 그게 여러개가 될수도 있는건가?) -> 싱글톤(객체의 생성을 1개로 제한)
- 어떻게?
 -private으로 다른곳에서 생성 제한	-> extern 또한 선언할 수 없음
 ->자기스스로를 만드는 함수를 멤버함수로
 ->그걸 호출하려면 객체가 있어야 하는데?
 ->객체가 없어도 호출가능한 멤버함수 만든다. -> static 사용 - this가 없기 때문

클래스에 선언된 정적 멤버(데이터영역) : 클래스객체의 생성, 해제와 상관없이 정적멤버는 데이터 영역에 하나 있음
 
25:15 그림설명

public으로 정적멤버 선언 시 외부에서도 범위지정 연산자를 통해 접근 가능 ex)CClass::m_iStatic = 0;

*문법규칙 : 정적멤버는 선언 시 클래스 밖에서 초기화를 해주어야 함. : 안해줄 시 링크에러(확인할 수 없는 외부 참조)





싱글톤(2)

싱글톤으로 만든 유일한 객체를 데이터 영역에 올리는 것

정적변수가 해당함수안에서만 접근가능한 것. 주소를 줄 경우는 접근가능(포인터의 장점) 이렇게 하면 해제에 신경 쓸 필요 x(동적할당과의 차이점)
																->차이점. 장점일까?->지울 수가 없다.
 - 이번 프로젝트에선 이 방식으로(동적할당 아닌 주소)
 - 이러한 관리자급 클래스를 많이 만들것이기 때문에 매크로 함수로

매크로 함수  12:00분 경 설명+주의점
->#define SINGLE(type) static type* GetInst(){ static type mgre;	return &mgr;}
-> 계속 활용함 -> 미리 컴파일된 헤더(일일이 참조x, 재컴파일 하지 않음)

void init();	// 초기화 함수, 메인에서 호출

Core 객체 초기화
 
Core 객체
 - 핸들, 해상도(메뉴바 등 제외, 물체가 그려질 부분)
 -int init(HWND _hWnd, POINT _ptResolution);	// 초기화 함수, 메인에서 호출
 -void progress(); // 메세지가 오지않는 대부분의 시간동안




Core 클래스2============================
SetWindowPos - 윈도우를 인자로 받음(C스타일. C++은 객체생성하고 그 안에 멤버변수가 있음)
			pos : 전체 좌표(메뉴바 포함)이므로 _ptResolution보다 큼 -> AdjustWindowRect 활용(12:00 설명)

RECT 자료형 - 사각형.왼위오아 정수4개
LPRECT : RECT*  . RECT의 포인터타입

메세지 기반구조를 바꾸기로 함 ->> 메세지가 오지않는 대부분의 시간동안에도 그리기가 되어야 하지 않나?(progress에서)
-> 커널오브젝트 DC필요함. 원래는 BeginPaint, EndPaint 를 활용 but 이것은 메세지 기반(EndPaint에서 무효화영역해제가 된다.)
-> 다른방식. 메세지가 있든 없든 -> GetDC, ReleaseDC를 활용한다

무작정 progress에 그리기를 하면? -> 대부분의 시간을 계속 덧그리게 될 것

렌더링 설명 33분쯤

CObject 클래스 생성 (물체)
멤버 : 좌표, 크기
 Core -> init 에서 초기화

progress를 update, render 두가지 과정으로 나눈다.

update에서 키입력처리 : 메세지기반에서는 키가들어옴->어떤키인데->처리
				update는 update하는 순간에 키가 무엇이냐->처리 (비동기 키 입출력 함수
				GetAsyncKeyState활용 - 반환값이 true/false가 아닌 키의 상태 -> onoff만 확인하려면 & 0x8000

그리기render까지 처리 했으나 지나간 자리가 아예 까매짐(테두리로 채워져버림.)->매순간 그려버렸기 때문 -> 어떻게 할지?



Timer(1)======================
매 순간 그리는 것이 개개인 pc속도차이에 따라 달라진다.? -> 이동속도 등이 다 다름 -> 모든 클라이언트에서 동일하게 
-> 시간 동기화(현실시간과 매칭)
->시간관리 매니저


시간관리 매니저 : 시간체크, 		활용:19분에 설명
(이동하고 싶은 양 * 컴퓨터의 한 프레임당 시간)=> 100을 이동하고 싶다 -> update마다 100 * DeltaTime이동 -> 어느 컴퓨터든 1초에 100이동하게 됨
	구해야하는 것 : FPS, 프레임당 시간(Delta Time)

-> QueryPerformanceCounter 활용


Timer(2)==

활용하여 Delta Time ( 1프레임에 걸리는 시간) 구하기
그의 역수 -> 1초당 프레임 FPS
but 어차피 프레임당 타임매니저가 호출됨.


Double Buffering=======================

렌더링 쪽엔 문제가 있음
	현재 잔상이 남음 -> 싹 다 지운다?or전체영역 사각형을 그린다(화면청소)? -> 1280x768의 모든 픽셀을 매 프레임마다?
					-> 수-수십만 프레임마다 지우고 그리는 중 -> 그런데 여기서 물체도 많아진다?
	=> 똑같은 그림을 하나 더 준비해서 그리는 과정이 아닌 다 그려지고 난 시점을 보여주자. ( 더블 버퍼링, 이중 버퍼링 )

-이중 버퍼링 용도의 비트맵과 DC를 "만든다".
CreateCompatibleBitmap	/ CreateCompatibleDC
HBITMAP hOldBit = (HBITMAP)SelectObject(m_memDC, m_hBit);
DeleteObject(hOldBit); <- 기존 1픽셀 비트맵 삭제

윈도우 내에는 비트맵데이터가 존재(윈도우가 보유한 픽셀데이터)

목표->완성된 그림을 보여주자. 새 윈도우를 만드는 그런 과정 없이
	-> 창이 필요한게 아니라 그림이 필요하다.->비트맵 활용		15분 설명


-이제 그리자!
	m_memDC에 그리기 -> 아직 보이진 않음 -> 그리고 복사하면 -> 완성된 화면이 보이게 됨
-그린 그림 복사
 	BitBlt : 한땀한땀 복사 -> 많은 반복과정 but 물체가 많아도 한땀한땀은 동일한 과정		** 나중엔 release버전
-> FPS가 많이 떨어짐 : 물체를 그리는 과정이 어마어마한 반복 -> CPU가 처리하기에는 부담		** -> GPU탄생	(Direct는 GPU활용)

30분경 지금까지한 과정 대체적으로 정리




Key Manager(1)========================
키 매니저의 역할 
1.프레임 동기화 : 동일 프레임 내에서 같은 키에 대해, 동일한 이벤트를 가져간다.
2. 키 입력 이벤트 처리 : tap, hold, away

- 현재 update에서는 호출되는 순간 특정 키가 눌렸나?를 확인 -> 영상 초반 설명 -> 동일 적용
															*한줄 복사 : 그냥 ctrl+c
enum class 키의 상태, 키

키 상태 정리
- 키를 막 누른경우		
- 누르고있는			-> 마치며 이전에 눌렸는지 여부를 참으로.

- 막 뗀
- 아닌				-> 마치며 이전에 눌렸는지 여부를 거짓으로.

Key Manager(2)========================
실행중인 창이 포커싱 중일 때만 키입력이 진행되도록		(설명)
마무리 설명
앞으로는 C++


Scene Manager(1)=====================
다형성 추상화 상속

화면에 존재하는 모든것이 오브젝트 (윈도우 등)
오브젝트 관리필요
										*해당 함수 선언으로 이동
define에서 enum class 그룹

vector<CObject*> m_arrObj[(UINT)GROUP_TYPE::END];	// 오브젝트를 저장 및 관리할 벡터를 그룹 개수만큼 선언

SceneMgr 생성

CScene은 직접사용할 클래스가 아니라 상속이 목적 ->> 소멸자의 가상함수를 무조건 해줘야함 (소멸자앞에 virtual)

**소멸자 virtual 공부

현재 오브젝트는 전역변수로 때려박음
-> 오브젝트를 동적할당하여 씬에 그려넣을 예정 -> 구조적 변화

Scene Manager(2)=====================
CScene에서 virtual void Enter()
	사용x, 자식씬들이 사용할 함수를 알리는 목적->순수가상함수 	virtual void Enter() = 0; -> 자식들이 반드시 구현해야 함
그리고 나서 자식에도 이미 가상함수지만 virtual로 명시적

외부x 자식o -> privacy->protected : 문제점 - 부모자식관계여도 멤버들을 지칭해서 접근가능 -> 디버깅 힘들어짐
		-> 함수만 protected로 하자 -> 해당 함수의 문제는 부모에서만 확인하면됨		(성향)

프로그래밍 -> 머리보다도 실수를 잘 잡을 수 있어야 편함
클래스는 헤더에 구현 하면 인라인

상속 : 코드의 재사용
삭제 또한 부모에서 일괄적으로

오브젝트 삭제, 
벡터는 신경쓸 필요 x ( 씬의 멤버이기 때문에 씬이 삭제될 때 벡터의 소멸자 호출)

상속으로 CCore에선 Mgr을 통해 각자 초기화,업데이트,렌더링

=> 프레임워크
이 16강까지가 WinAPI의 전체적인 흐름

앞으로 - 사각형 아닌 이미지(캐릭터) / 충돌(상호작용) / 텍스처


Object(1)=====================
Object의 update부분의 문제 : 부모격인 클래스에 이동기능 -> 자식또한 전부 그럴 수 있음 -> 수정 필요

-> 모든 오브젝트마다의 update

Player 생성
이동 기능 옮겨옴

CObject자체는 객체화 x.  just 부모 -> 순수가상함수 클래스로 만들기 -> 추상클래스로 만들기
-> 직접적인 동적할당 불가능

10분경 설명

몬스터 생성
속도, 중앙값(좌우로 움직일 기준), 범위, 방향

30분경 설명(방향)


*변수 선언과 동시에 대입 시 복사생성자로 됨
-> 같은 타입이 아니라면 생성자에서 해결해주기

몬스터 여러마리 생성
위치, 중앙값, 범위, 방향 등 이용하여 Set,Get함수와 함께 for문으로 다중생성

Object(2)=====================
미사일 생성
플레이어냐 몬스터냐에 따라 방향이 다름


수업목표 : 원하는 것을 만들려면? 추가 기능
과제 : 몬스터 배치. 몬스터가 미사일 쏘게 하기. 랜덤성부여. 미사일의 움직임or 미사일을 세방향으로 쏘거나....패턴
	-> 다양화
23분 설명

앞으로 리소스 추가(사운드, 소리 등) 이 또한 부모자식


기초수학=============================
삼각함수 개념, 호도법(라디안), 원주율, 내적(벡터,스칼라), 외적(3d대비), 공간도형(3d)-3차원벡터

윈도우는 위아래 반대

이동시킬때는 각도보다 벡터사용이 직관적

normalize 


Resoutce(1)============================
텍스처 - 이미지데이터(물체의 표면정보)

리소스들이 공통적으로 가져야 할 것 - 부모가 가져야 할 것 - 고유한 키 값
									- 리소스의 상대경로


Path Manager===========================
텍스처 : 리소스 상속, 멤버로 dc와 bitmap이 필요함
	로딩하게 될 이미지도 비트맵 형태로 픽셀데이터를 가지고 있을것이고
	그것을 연결시켜줄 dc
	-> 텍스처
	둘 다 커널오브젝트를 저장하기위한 변수

LoadImage		경로(인자로 받아온경로),IMAGE_BITMAP형태 , 가로,세로길이, ( LR_CREATEDIBSECTION | LR_LOADFROMFILE)

경로를 받아와야함
